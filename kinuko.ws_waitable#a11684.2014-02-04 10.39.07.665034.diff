diff --git Source/modules/websockets/ThreadableWebSocketChannelClientWrapper.cpp Source/modules/websockets/ThreadableWebSocketChannelClientWrapper.cpp
index dc78172..b7259f0 100644
--- Source/modules/websockets/ThreadableWebSocketChannelClientWrapper.cpp
+++ Source/modules/websockets/ThreadableWebSocketChannelClientWrapper.cpp
@@ -41,11 +41,6 @@ namespace WebCore {
 ThreadableWebSocketChannelClientWrapper::ThreadableWebSocketChannelClientWrapper(ExecutionContext* context, WebSocketChannelClient* client)
     : m_context(context)
     , m_client(client)
-    , m_peer(0)
-    , m_failedWebSocketChannelCreation(false)
-    , m_syncMethodDone(true)
-    , m_sendRequestResult(WebSocketChannel::SendFail)
-    , m_bufferedAmount(0)
     , m_suspended(false)
 {
 }
@@ -55,47 +50,6 @@ PassRefPtr<ThreadableWebSocketChannelClientWrapper> ThreadableWebSocketChannelCl
     return adoptRef(new ThreadableWebSocketChannelClientWrapper(context, client));
 }
 
-void ThreadableWebSocketChannelClientWrapper::clearSyncMethodDone()
-{
-    m_syncMethodDone = false;
-}
-
-void ThreadableWebSocketChannelClientWrapper::setSyncMethodDone()
-{
-    m_syncMethodDone = true;
-}
-
-bool ThreadableWebSocketChannelClientWrapper::syncMethodDone() const
-{
-    return m_syncMethodDone;
-}
-
-WorkerThreadableWebSocketChannel::Peer* ThreadableWebSocketChannelClientWrapper::peer() const
-{
-    return m_peer;
-}
-
-void ThreadableWebSocketChannelClientWrapper::didCreateWebSocketChannel(WorkerThreadableWebSocketChannel::Peer* peer)
-{
-    m_peer = peer;
-    m_syncMethodDone = true;
-}
-
-void ThreadableWebSocketChannelClientWrapper::clearPeer()
-{
-    m_peer = 0;
-}
-
-bool ThreadableWebSocketChannelClientWrapper::failedWebSocketChannelCreation() const
-{
-    return m_failedWebSocketChannelCreation;
-}
-
-void ThreadableWebSocketChannelClientWrapper::setFailedWebSocketChannelCreation()
-{
-    m_failedWebSocketChannelCreation = true;
-}
-
 String ThreadableWebSocketChannelClientWrapper::subprotocol() const
 {
     if (m_subprotocol.isEmpty())
@@ -122,28 +76,6 @@ void ThreadableWebSocketChannelClientWrapper::setExtensions(const String& extens
     append(m_extensions, extensions);
 }
 
-WebSocketChannel::SendResult ThreadableWebSocketChannelClientWrapper::sendRequestResult() const
-{
-    return m_sendRequestResult;
-}
-
-void ThreadableWebSocketChannelClientWrapper::setSendRequestResult(WebSocketChannel::SendResult sendRequestResult)
-{
-    m_sendRequestResult = sendRequestResult;
-    m_syncMethodDone = true;
-}
-
-unsigned long ThreadableWebSocketChannelClientWrapper::bufferedAmount() const
-{
-    return m_bufferedAmount;
-}
-
-void ThreadableWebSocketChannelClientWrapper::setBufferedAmount(unsigned long bufferedAmount)
-{
-    m_bufferedAmount = bufferedAmount;
-    m_syncMethodDone = true;
-}
-
 void ThreadableWebSocketChannelClientWrapper::clearClient()
 {
     m_client = 0;
@@ -219,12 +151,6 @@ void ThreadableWebSocketChannelClientWrapper::processPendingTasks()
 {
     if (m_suspended)
         return;
-    if (!m_syncMethodDone) {
-        // When a synchronous operation is in progress (i.e. the execution stack contains
-        // WorkerThreadableWebSocketChannel::waitForMethodCompletion()), we cannot invoke callbacks in this run loop.
-        m_context->postTask(createCallbackTask(&ThreadableWebSocketChannelClientWrapper::processPendingTasksCallback, this));
-        return;
-    }
     Vector<OwnPtr<ExecutionContextTask> > tasks;
     tasks.swap(m_pendingTasks);
     for (Vector<OwnPtr<ExecutionContextTask> >::const_iterator iter = tasks.begin(); iter != tasks.end(); ++iter)
diff --git Source/modules/websockets/ThreadableWebSocketChannelClientWrapper.h Source/modules/websockets/ThreadableWebSocketChannelClientWrapper.h
index 0458acf..0903232 100644
--- Source/modules/websockets/ThreadableWebSocketChannelClientWrapper.h
+++ Source/modules/websockets/ThreadableWebSocketChannelClientWrapper.h
@@ -34,7 +34,6 @@
 #include "core/dom/ExecutionContext.h"
 #include "modules/websockets/WebSocketChannel.h"
 #include "modules/websockets/WebSocketChannelClient.h"
-#include "modules/websockets/WorkerThreadableWebSocketChannel.h"
 #include "wtf/Forward.h"
 #include "wtf/OwnPtr.h"
 #include "wtf/PassOwnPtr.h"
@@ -51,29 +50,12 @@ class ThreadableWebSocketChannelClientWrapper : public ThreadSafeRefCounted<Thre
 public:
     static PassRefPtr<ThreadableWebSocketChannelClientWrapper> create(ExecutionContext*, WebSocketChannelClient*);
 
-    void clearSyncMethodDone();
-    void setSyncMethodDone();
-    bool syncMethodDone() const;
-
-    WorkerThreadableWebSocketChannel::Peer* peer() const;
-    void didCreateWebSocketChannel(WorkerThreadableWebSocketChannel::Peer*);
-    void clearPeer();
-
-    bool failedWebSocketChannelCreation() const;
-    void setFailedWebSocketChannelCreation();
-
     // Subprotocol and extensions will be available when didConnect() callback is invoked.
     String subprotocol() const;
     void setSubprotocol(const String&);
     String extensions() const;
     void setExtensions(const String&);
 
-    WebSocketChannel::SendResult sendRequestResult() const;
-    void setSendRequestResult(WebSocketChannel::SendResult);
-
-    unsigned long bufferedAmount() const;
-    void setBufferedAmount(unsigned long);
-
     void clearClient();
 
     void didConnect();
@@ -103,14 +85,9 @@ private:
 
     ExecutionContext* m_context;
     WebSocketChannelClient* m_client;
-    WorkerThreadableWebSocketChannel::Peer* m_peer;
-    bool m_failedWebSocketChannelCreation;
-    bool m_syncMethodDone;
     // ThreadSafeRefCounted must not have String member variables.
     Vector<UChar> m_subprotocol;
     Vector<UChar> m_extensions;
-    WebSocketChannel::SendResult m_sendRequestResult;
-    unsigned long m_bufferedAmount;
     bool m_suspended;
     Vector<OwnPtr<ExecutionContextTask> > m_pendingTasks;
 };
diff --git Source/modules/websockets/WorkerThreadableWebSocketChannel.cpp Source/modules/websockets/WorkerThreadableWebSocketChannel.cpp
index 1430eda..b7f3b7c 100644
--- Source/modules/websockets/WorkerThreadableWebSocketChannel.cpp
+++ Source/modules/websockets/WorkerThreadableWebSocketChannel.cpp
@@ -37,6 +37,7 @@
 #include "core/dom/CrossThreadTask.h"
 #include "core/dom/Document.h"
 #include "core/dom/ExecutionContext.h"
+#include "core/dom/ExecutionContextTask.h"
 #include "core/fileapi/Blob.h"
 #include "core/inspector/ScriptCallFrame.h"
 #include "core/inspector/ScriptCallStack.h"
@@ -46,11 +47,64 @@
 #include "modules/websockets/MainThreadWebSocketChannel.h"
 #include "modules/websockets/NewWebSocketChannelImpl.h"
 #include "modules/websockets/ThreadableWebSocketChannelClientWrapper.h"
+#include "public/platform/Platform.h"
+#include "public/platform/WebWaitableEvent.h"
 #include "wtf/ArrayBuffer.h"
+#include "wtf/Functional.h"
 #include "wtf/MainThread.h"
 
 namespace WebCore {
 
+// Created and destroyed on the worker thread. All setters of this class are
+// called on the main thread, while all getters are called on the worker
+// thread. signalWorkerThread() must be called before any getters are called.
+class ThreadableWebSocketChannelSyncHelper {
+public:
+    static PassOwnPtr<ThreadableWebSocketChannelSyncHelper> create(blink::WebWaitableEvent& event)
+    {
+        return adoptPtr(new ThreadableWebSocketChannelSyncHelper(event));
+    }
+
+    // All setters are called on the main thread.
+    void setSendRequestResult(WebSocketChannel::SendResult sendRequestResult)
+    {
+        m_sendRequestResult = sendRequestResult;
+    }
+    void setBufferedAmount(unsigned long bufferedAmount)
+    {
+        m_bufferedAmount = bufferedAmount;
+    }
+
+    // All getter are called on the worker thread.
+    WebSocketChannel::SendResult sendRequestResult() const
+    {
+        return m_sendRequestResult;
+    }
+    unsigned long bufferedAmount() const
+    {
+        return m_bufferedAmount;
+    }
+
+    // This should be called after all setters are called and before any
+    // getters are called.
+    void signalWorkerThread()
+    {
+        m_event.signal();
+    }
+
+private:
+    ThreadableWebSocketChannelSyncHelper(blink::WebWaitableEvent& event)
+        : m_event(event)
+        , m_sendRequestResult(WebSocketChannel::SendFail)
+        , m_bufferedAmount(0)
+    {
+    }
+
+    blink::WebWaitableEvent& m_event;
+    WebSocketChannel::SendResult m_sendRequestResult;
+    unsigned long m_bufferedAmount;
+};
+
 WorkerThreadableWebSocketChannel::WorkerThreadableWebSocketChannel(WorkerGlobalScope* context, WebSocketChannelClient* client, const String& taskMode, const String& sourceURL, unsigned lineNumber)
     : m_workerGlobalScope(context)
     , m_workerClientWrapper(ThreadableWebSocketChannelClientWrapper::create(context, client))
@@ -160,19 +214,23 @@ void WorkerThreadableWebSocketChannel::resume()
         m_bridge->resume();
 }
 
-WorkerThreadableWebSocketChannel::Peer::Peer(PassRefPtr<ThreadableWebSocketChannelClientWrapper> clientWrapper, WorkerLoaderProxy& loaderProxy, ExecutionContext* context, const String& taskMode, const String& sourceURL, unsigned lineNumber)
-    : m_workerClientWrapper(clientWrapper)
+WorkerThreadableWebSocketChannel::Peer::Peer(PassRefPtr<WeakReference<Peer> > reference, PassRefPtr<ThreadableWebSocketChannelClientWrapper> clientWrapper, WorkerLoaderProxy& loaderProxy, ExecutionContext* context, const String& taskMode, const String& sourceURL, unsigned lineNumber, ThreadableWebSocketChannelSyncHelper& syncHelper)
+    : m_weakFactory(reference, this)
+    , m_workerClientWrapper(clientWrapper)
     , m_loaderProxy(loaderProxy)
     , m_mainWebSocketChannel(0)
     , m_taskMode(taskMode)
+    , m_syncHelper(syncHelper)
 {
+    ASSERT(isMainThread());
     Document* document = toDocument(context);
     if (RuntimeEnabledFeatures::experimentalWebSocketEnabled()) {
         m_mainWebSocketChannel = NewWebSocketChannelImpl::create(document, this, sourceURL, lineNumber);
     } else {
         m_mainWebSocketChannel = MainThreadWebSocketChannel::create(document, this, sourceURL, lineNumber);
     }
-    ASSERT(isMainThread());
+
+    m_syncHelper.signalWorkerThread();
 }
 
 WorkerThreadableWebSocketChannel::Peer::~Peer()
@@ -182,60 +240,73 @@ WorkerThreadableWebSocketChannel::Peer::~Peer()
         m_mainWebSocketChannel->disconnect();
 }
 
-void WorkerThreadableWebSocketChannel::Peer::connect(const KURL& url, const String& protocol)
+void WorkerThreadableWebSocketChannel::Peer::initialize(ExecutionContext* context, PassRefPtr<WeakReference<Peer> > reference, WorkerLoaderProxy* loaderProxy, PassRefPtr<ThreadableWebSocketChannelClientWrapper> clientWrapper, const String& taskMode, const String& sourceURLAtConnection, unsigned lineNumberAtConnection, ThreadableWebSocketChannelSyncHelper* syncHelper)
 {
-    ASSERT(isMainThread());
-    if (!m_mainWebSocketChannel)
-        return;
-    m_mainWebSocketChannel->connect(url, protocol);
+    // The caller must call destroy() to free the peer.
+    new Peer(reference, clientWrapper, *loaderProxy, context, taskMode, sourceURLAtConnection, lineNumberAtConnection, *syncHelper);
 }
 
-static void workerGlobalScopeDidSend(ExecutionContext* context, PassRefPtr<ThreadableWebSocketChannelClientWrapper> workerClientWrapper, WebSocketChannel::SendResult sendRequestResult)
+void WorkerThreadableWebSocketChannel::Peer::destroy()
 {
-    ASSERT_UNUSED(context, context->isWorkerGlobalScope());
-    workerClientWrapper->setSendRequestResult(sendRequestResult);
+    ASSERT(isMainThread());
+    delete this;
 }
 
-void WorkerThreadableWebSocketChannel::Peer::send(const String& message)
+void WorkerThreadableWebSocketChannel::Peer::connect(const KURL& url, const String& protocol)
 {
     ASSERT(isMainThread());
-    if (!m_mainWebSocketChannel || !m_workerClientWrapper)
+    if (!m_mainWebSocketChannel)
         return;
-    WebSocketChannel::SendResult sendRequestResult = m_mainWebSocketChannel->send(message);
-    m_loaderProxy.postTaskForModeToWorkerGlobalScope(createCallbackTask(&workerGlobalScopeDidSend, m_workerClientWrapper, sendRequestResult), m_taskMode);
+    m_mainWebSocketChannel->connect(url, protocol);
 }
 
-void WorkerThreadableWebSocketChannel::Peer::send(const ArrayBuffer& binaryData)
+void WorkerThreadableWebSocketChannel::Peer::send(const String& message)
 {
     ASSERT(isMainThread());
-    if (!m_mainWebSocketChannel || !m_workerClientWrapper)
-        return;
-    WebSocketChannel::SendResult sendRequestResult = m_mainWebSocketChannel->send(binaryData, 0, binaryData.byteLength());
-    m_loaderProxy.postTaskForModeToWorkerGlobalScope(createCallbackTask(&workerGlobalScopeDidSend, m_workerClientWrapper, sendRequestResult), m_taskMode);
+    if (!m_mainWebSocketChannel || !m_workerClientWrapper) {
+        m_syncHelper.setSendRequestResult(WebSocketChannel::SendFail);
+    } else {
+        WebSocketChannel::SendResult sendRequestResult = m_mainWebSocketChannel->send(message);
+        m_syncHelper.setSendRequestResult(sendRequestResult);
+    }
+    m_syncHelper.signalWorkerThread();
 }
 
-void WorkerThreadableWebSocketChannel::Peer::send(PassRefPtr<BlobDataHandle> blobData)
+void WorkerThreadableWebSocketChannel::Peer::sendArrayBuffer(PassOwnPtr<Vector<char> > data)
 {
     ASSERT(isMainThread());
-    if (!m_mainWebSocketChannel || !m_workerClientWrapper)
-        return;
-    WebSocketChannel::SendResult sendRequestResult = m_mainWebSocketChannel->send(blobData);
-    m_loaderProxy.postTaskForModeToWorkerGlobalScope(createCallbackTask(&workerGlobalScopeDidSend, m_workerClientWrapper, sendRequestResult), m_taskMode);
+    if (!m_mainWebSocketChannel || !m_workerClientWrapper) {
+        m_syncHelper.setSendRequestResult(WebSocketChannel::SendFail);
+    } else {
+        RefPtr<ArrayBuffer> binaryData = ArrayBuffer::create(data->data(), data->size());
+        WebSocketChannel::SendResult sendRequestResult = m_mainWebSocketChannel->send(*binaryData, 0, binaryData->byteLength());
+        m_syncHelper.setSendRequestResult(sendRequestResult);
+    }
+    m_syncHelper.signalWorkerThread();
 }
 
-static void workerGlobalScopeDidGetBufferedAmount(ExecutionContext* context, PassRefPtr<ThreadableWebSocketChannelClientWrapper> workerClientWrapper, unsigned long bufferedAmount)
+void WorkerThreadableWebSocketChannel::Peer::sendBlob(PassRefPtr<BlobDataHandle> blobData)
 {
-    ASSERT_UNUSED(context, context->isWorkerGlobalScope());
-    workerClientWrapper->setBufferedAmount(bufferedAmount);
+    ASSERT(isMainThread());
+    if (!m_mainWebSocketChannel || !m_workerClientWrapper) {
+        m_syncHelper.setSendRequestResult(WebSocketChannel::SendFail);
+    } else {
+        WebSocketChannel::SendResult sendRequestResult = m_mainWebSocketChannel->send(blobData);
+        m_syncHelper.setSendRequestResult(sendRequestResult);
+    }
+    m_syncHelper.signalWorkerThread();
 }
 
 void WorkerThreadableWebSocketChannel::Peer::bufferedAmount()
 {
     ASSERT(isMainThread());
-    if (!m_mainWebSocketChannel || !m_workerClientWrapper)
-        return;
-    unsigned long bufferedAmount = m_mainWebSocketChannel->bufferedAmount();
-    m_loaderProxy.postTaskForModeToWorkerGlobalScope(createCallbackTask(&workerGlobalScopeDidGetBufferedAmount, m_workerClientWrapper, bufferedAmount), m_taskMode);
+    if (!m_mainWebSocketChannel || !m_workerClientWrapper) {
+        m_syncHelper.setBufferedAmount(0);
+    } else {
+        unsigned long bufferedAmount = m_mainWebSocketChannel->bufferedAmount();
+        m_syncHelper.setBufferedAmount(bufferedAmount);
+    }
+    m_syncHelper.signalWorkerThread();
 }
 
 void WorkerThreadableWebSocketChannel::Peer::close(int code, const String& reason)
@@ -371,7 +442,8 @@ WorkerThreadableWebSocketChannel::Bridge::Bridge(PassRefPtr<ThreadableWebSocketC
     , m_workerGlobalScope(workerGlobalScope)
     , m_loaderProxy(m_workerGlobalScope->thread()->workerLoaderProxy())
     , m_taskMode(taskMode)
-    , m_peer(0)
+    , m_syncEvent(adoptPtr(blink::Platform::current()->createWaitableEvent()))
+    , m_syncHelper(ThreadableWebSocketChannelSyncHelper::create(*m_syncEvent))
 {
     ASSERT(m_workerClientWrapper.get());
 }
@@ -381,267 +453,95 @@ WorkerThreadableWebSocketChannel::Bridge::~Bridge()
     disconnect();
 }
 
-class WorkerThreadableWebSocketChannel::WorkerGlobalScopeDidInitializeTask FINAL : public ExecutionContextTask {
-public:
-    static PassOwnPtr<ExecutionContextTask> create(WorkerThreadableWebSocketChannel::Peer* peer, WorkerLoaderProxy* loaderProxy, PassRefPtr<ThreadableWebSocketChannelClientWrapper> workerClientWrapper)
-    {
-        return adoptPtr(new WorkerGlobalScopeDidInitializeTask(peer, loaderProxy, workerClientWrapper));
-    }
-
-    virtual ~WorkerGlobalScopeDidInitializeTask() { }
-    virtual void performTask(ExecutionContext* context) OVERRIDE
-    {
-        ASSERT_UNUSED(context, context->isWorkerGlobalScope());
-        if (m_workerClientWrapper->failedWebSocketChannelCreation()) {
-            // If Bridge::initialize() quitted earlier, we need to kick mainThreadDestroy() to delete the peer.
-            OwnPtr<WorkerThreadableWebSocketChannel::Peer> peer = adoptPtr(m_peer);
-            m_peer = 0;
-            m_loaderProxy->postTaskToLoader(createCallbackTask(&WorkerThreadableWebSocketChannel::mainThreadDestroy, peer.release()));
-        } else {
-            m_workerClientWrapper->didCreateWebSocketChannel(m_peer);
-        }
-    }
-    virtual bool isCleanupTask() const OVERRIDE { return true; }
-
-private:
-    WorkerGlobalScopeDidInitializeTask(WorkerThreadableWebSocketChannel::Peer* peer, WorkerLoaderProxy* loaderProxy, PassRefPtr<ThreadableWebSocketChannelClientWrapper> workerClientWrapper)
-        : m_peer(peer)
-        , m_loaderProxy(loaderProxy)
-        , m_workerClientWrapper(workerClientWrapper)
-    {
-    }
-
-    WorkerThreadableWebSocketChannel::Peer* m_peer;
-    WorkerLoaderProxy* m_loaderProxy;
-    RefPtr<ThreadableWebSocketChannelClientWrapper> m_workerClientWrapper;
-};
-
-void WorkerThreadableWebSocketChannel::Bridge::mainThreadInitialize(ExecutionContext* context, WorkerLoaderProxy* loaderProxy, PassRefPtr<ThreadableWebSocketChannelClientWrapper> prpClientWrapper, const String& taskMode, const String& sourceURL, unsigned lineNumber)
-{
-    ASSERT(isMainThread());
-    ASSERT_UNUSED(context, context->isDocument());
-
-    RefPtr<ThreadableWebSocketChannelClientWrapper> clientWrapper = prpClientWrapper;
-
-    Peer* peer = Peer::create(clientWrapper, *loaderProxy, context, taskMode, sourceURL, lineNumber);
-    bool sent = loaderProxy->postTaskForModeToWorkerGlobalScope(
-        WorkerThreadableWebSocketChannel::WorkerGlobalScopeDidInitializeTask::create(peer, loaderProxy, clientWrapper), taskMode);
-    if (!sent) {
-        clientWrapper->clearPeer();
-        delete peer;
-    }
-}
-
 void WorkerThreadableWebSocketChannel::Bridge::initialize(const String& sourceURL, unsigned lineNumber)
 {
-    ASSERT(!m_peer);
-    setMethodNotCompleted();
-    RefPtr<Bridge> protect(this);
-    m_loaderProxy.postTaskToLoader(
-        createCallbackTask(&Bridge::mainThreadInitialize, AllowCrossThreadAccess(&m_loaderProxy), m_workerClientWrapper, m_taskMode, sourceURL, lineNumber));
-    waitForMethodCompletion();
-    // m_peer may be null when the nested runloop exited before a peer has created.
-    m_peer = m_workerClientWrapper->peer();
-    if (!m_peer)
-        m_workerClientWrapper->setFailedWebSocketChannelCreation();
-}
+    RefPtr<WeakReference<Peer> > reference = WeakReference<Peer>::createUnbound();
+    m_peer = WeakPtr<Peer>(reference);
 
-void WorkerThreadableWebSocketChannel::mainThreadConnect(ExecutionContext* context, Peer* peer, const KURL& url, const String& protocol)
-{
-    ASSERT(isMainThread());
-    ASSERT_UNUSED(context, context->isDocument());
-    ASSERT(peer);
-
-    peer->connect(url, protocol);
+    RefPtr<Bridge> protect(this);
+    m_loaderProxy.postTaskToLoader(createCallbackTask(&Peer::initialize, reference.release(), AllowCrossThreadAccess(&m_loaderProxy), m_workerClientWrapper, m_taskMode.isolatedCopy(), sourceURL.isolatedCopy(), lineNumber, AllowCrossThreadAccess(m_syncHelper.get())));
+    if (!waitForMethodCompletion()) {
+        // The worker thread has been signalled to shutdown before method completion.
+        m_loaderProxy.postTaskToLoader(CallClosureTask::create(bind(&Peer::destroy, m_peer)));
+        m_workerGlobalScope = 0;
+    }
 }
 
 void WorkerThreadableWebSocketChannel::Bridge::connect(const KURL& url, const String& protocol)
 {
     ASSERT(m_workerClientWrapper);
-    if (!m_peer)
-        return;
-    m_loaderProxy.postTaskToLoader(createCallbackTask(&WorkerThreadableWebSocketChannel::mainThreadConnect, AllowCrossThreadAccess(m_peer), url, protocol));
-}
-
-void WorkerThreadableWebSocketChannel::mainThreadSend(ExecutionContext* context, Peer* peer, const String& message)
-{
-    ASSERT(isMainThread());
-    ASSERT_UNUSED(context, context->isDocument());
-    ASSERT(peer);
-
-    peer->send(message);
-}
-
-void WorkerThreadableWebSocketChannel::mainThreadSendArrayBuffer(ExecutionContext* context, Peer* peer, PassOwnPtr<Vector<char> > data)
-{
-    ASSERT(isMainThread());
-    ASSERT_UNUSED(context, context->isDocument());
-    ASSERT(peer);
-
-    RefPtr<ArrayBuffer> arrayBuffer = ArrayBuffer::create(data->data(), data->size());
-    peer->send(*arrayBuffer);
-}
-
-void WorkerThreadableWebSocketChannel::mainThreadSendBlob(ExecutionContext* context, Peer* peer, PassRefPtr<BlobDataHandle> data)
-{
-    ASSERT(isMainThread());
-    ASSERT_UNUSED(context, context->isDocument());
-    ASSERT(peer);
-    peer->send(data);
+    m_loaderProxy.postTaskToLoader(CallClosureTask::create(bind(&Peer::connect, m_peer, url, protocol.isolatedCopy())));
 }
 
 WebSocketChannel::SendResult WorkerThreadableWebSocketChannel::Bridge::send(const String& message)
 {
-    if (!m_workerClientWrapper || !m_peer)
+    if (!m_workerClientWrapper || !m_workerGlobalScope)
         return WebSocketChannel::SendFail;
-    setMethodNotCompleted();
-    m_loaderProxy.postTaskToLoader(createCallbackTask(&WorkerThreadableWebSocketChannel::mainThreadSend, AllowCrossThreadAccess(m_peer), message));
+    m_loaderProxy.postTaskToLoader(CallClosureTask::create(bind(&Peer::send, m_peer, message.isolatedCopy())));
     RefPtr<Bridge> protect(this);
     waitForMethodCompletion();
-    ThreadableWebSocketChannelClientWrapper* clientWrapper = m_workerClientWrapper.get();
-    if (!clientWrapper)
-        return WebSocketChannel::SendFail;
-    return clientWrapper->sendRequestResult();
+    return m_syncHelper->sendRequestResult();
 }
 
 WebSocketChannel::SendResult WorkerThreadableWebSocketChannel::Bridge::send(const ArrayBuffer& binaryData, unsigned byteOffset, unsigned byteLength)
 {
-    if (!m_workerClientWrapper || !m_peer)
+    if (!m_workerClientWrapper || !m_workerGlobalScope)
         return WebSocketChannel::SendFail;
     // ArrayBuffer isn't thread-safe, hence the content of ArrayBuffer is copied into Vector<char>.
     OwnPtr<Vector<char> > data = adoptPtr(new Vector<char>(byteLength));
     if (binaryData.byteLength())
         memcpy(data->data(), static_cast<const char*>(binaryData.data()) + byteOffset, byteLength);
-    setMethodNotCompleted();
-    m_loaderProxy.postTaskToLoader(createCallbackTask(&WorkerThreadableWebSocketChannel::mainThreadSendArrayBuffer, AllowCrossThreadAccess(m_peer), data.release()));
+    m_loaderProxy.postTaskToLoader(CallClosureTask::create(bind(&Peer::sendArrayBuffer, m_peer, data.release())));
     RefPtr<Bridge> protect(this);
     waitForMethodCompletion();
-    ThreadableWebSocketChannelClientWrapper* clientWrapper = m_workerClientWrapper.get();
-    if (!clientWrapper)
-        return WebSocketChannel::SendFail;
-    return clientWrapper->sendRequestResult();
+    return m_syncHelper->sendRequestResult();
 }
 
 WebSocketChannel::SendResult WorkerThreadableWebSocketChannel::Bridge::send(PassRefPtr<BlobDataHandle> data)
 {
-    if (!m_workerClientWrapper || !m_peer)
+    if (!m_workerClientWrapper || !m_workerGlobalScope)
         return WebSocketChannel::SendFail;
-    setMethodNotCompleted();
-    m_loaderProxy.postTaskToLoader(createCallbackTask(&WorkerThreadableWebSocketChannel::mainThreadSendBlob, AllowCrossThreadAccess(m_peer), data));
+    m_loaderProxy.postTaskToLoader(CallClosureTask::create(bind(&Peer::sendBlob, m_peer, data)));
     RefPtr<Bridge> protect(this);
     waitForMethodCompletion();
-    ThreadableWebSocketChannelClientWrapper* clientWrapper = m_workerClientWrapper.get();
-    if (!clientWrapper)
-        return WebSocketChannel::SendFail;
-    return clientWrapper->sendRequestResult();
-}
-
-void WorkerThreadableWebSocketChannel::mainThreadBufferedAmount(ExecutionContext* context, Peer* peer)
-{
-    ASSERT(isMainThread());
-    ASSERT_UNUSED(context, context->isDocument());
-    ASSERT(peer);
-
-    peer->bufferedAmount();
+    return m_syncHelper->sendRequestResult();
 }
 
 unsigned long WorkerThreadableWebSocketChannel::Bridge::bufferedAmount()
 {
-    if (!m_workerClientWrapper || !m_peer)
+    if (!m_workerClientWrapper || !m_workerGlobalScope)
         return 0;
-    setMethodNotCompleted();
-    m_loaderProxy.postTaskToLoader(createCallbackTask(&WorkerThreadableWebSocketChannel::mainThreadBufferedAmount, AllowCrossThreadAccess(m_peer)));
+    m_loaderProxy.postTaskToLoader(CallClosureTask::create(bind(&Peer::bufferedAmount, m_peer)));
     RefPtr<Bridge> protect(this);
     waitForMethodCompletion();
-    ThreadableWebSocketChannelClientWrapper* clientWrapper = m_workerClientWrapper.get();
-    if (clientWrapper)
-        return clientWrapper->bufferedAmount();
-    return 0;
-}
-
-void WorkerThreadableWebSocketChannel::mainThreadClose(ExecutionContext* context, Peer* peer, int code, const String& reason)
-{
-    ASSERT(isMainThread());
-    ASSERT_UNUSED(context, context->isDocument());
-    ASSERT(peer);
-
-    peer->close(code, reason);
+    return m_syncHelper->bufferedAmount();
 }
 
 void WorkerThreadableWebSocketChannel::Bridge::close(int code, const String& reason)
 {
-    if (!m_peer)
-        return;
-    m_loaderProxy.postTaskToLoader(createCallbackTask(&WorkerThreadableWebSocketChannel::mainThreadClose, AllowCrossThreadAccess(m_peer), code, reason));
-}
-
-void WorkerThreadableWebSocketChannel::mainThreadFail(ExecutionContext* context, Peer* peer, const String& reason, MessageLevel level, const String& sourceURL, unsigned lineNumber)
-{
-    ASSERT(isMainThread());
-    ASSERT_UNUSED(context, context->isDocument());
-    ASSERT(peer);
-
-    peer->fail(reason, level, sourceURL, lineNumber);
+    m_loaderProxy.postTaskToLoader(CallClosureTask::create(bind(&Peer::close, m_peer, code, reason.isolatedCopy())));
 }
 
 void WorkerThreadableWebSocketChannel::Bridge::fail(const String& reason, MessageLevel level, const String& sourceURL, unsigned lineNumber)
 {
-    if (!m_peer)
-        return;
-    m_loaderProxy.postTaskToLoader(createCallbackTask(&WorkerThreadableWebSocketChannel::mainThreadFail, AllowCrossThreadAccess(m_peer), reason, level, sourceURL, lineNumber));
-}
-
-void WorkerThreadableWebSocketChannel::mainThreadDestroy(ExecutionContext* context, PassOwnPtr<Peer> peer)
-{
-    ASSERT(isMainThread());
-    ASSERT_UNUSED(context, context->isDocument());
-    ASSERT_UNUSED(peer, peer);
-
-    // Peer object will be deleted even if the task does not run in the main thread's cleanup period, because
-    // the destructor for the task object (created by createCallbackTask()) will automatically delete the peer.
+    m_loaderProxy.postTaskToLoader(CallClosureTask::create(bind(&Peer::fail, m_peer, reason.isolatedCopy(), level, sourceURL.isolatedCopy(), lineNumber)));
 }
 
 void WorkerThreadableWebSocketChannel::Bridge::disconnect()
 {
     clearClientWrapper();
-    if (m_peer) {
-        OwnPtr<Peer> peer = adoptPtr(m_peer);
-        m_peer = 0;
-        m_loaderProxy.postTaskToLoader(createCallbackTask(&WorkerThreadableWebSocketChannel::mainThreadDestroy, peer.release()));
-    }
+    m_loaderProxy.postTaskToLoader(CallClosureTask::create(bind(&Peer::destroy, m_peer)));
     m_workerGlobalScope = 0;
 }
 
-void WorkerThreadableWebSocketChannel::mainThreadSuspend(ExecutionContext* context, Peer* peer)
-{
-    ASSERT(isMainThread());
-    ASSERT_UNUSED(context, context->isDocument());
-    ASSERT(peer);
-
-    peer->suspend();
-}
-
 void WorkerThreadableWebSocketChannel::Bridge::suspend()
 {
-    if (!m_peer)
-        return;
-    m_loaderProxy.postTaskToLoader(createCallbackTask(&WorkerThreadableWebSocketChannel::mainThreadSuspend, AllowCrossThreadAccess(m_peer)));
-}
-
-void WorkerThreadableWebSocketChannel::mainThreadResume(ExecutionContext* context, Peer* peer)
-{
-    ASSERT(isMainThread());
-    ASSERT_UNUSED(context, context->isDocument());
-    ASSERT(peer);
-
-    peer->resume();
+    m_loaderProxy.postTaskToLoader(CallClosureTask::create(bind(&Peer::suspend, m_peer)));
 }
 
 void WorkerThreadableWebSocketChannel::Bridge::resume()
 {
-    if (!m_peer)
-        return;
-    m_loaderProxy.postTaskToLoader(createCallbackTask(&WorkerThreadableWebSocketChannel::mainThreadResume, AllowCrossThreadAccess(m_peer)));
+    m_loaderProxy.postTaskToLoader(CallClosureTask::create(bind(&Peer::resume, m_peer)));
 }
 
 void WorkerThreadableWebSocketChannel::Bridge::clearClientWrapper()
@@ -649,25 +549,21 @@ void WorkerThreadableWebSocketChannel::Bridge::clearClientWrapper()
     m_workerClientWrapper->clearClient();
 }
 
-void WorkerThreadableWebSocketChannel::Bridge::setMethodNotCompleted()
-{
-    ASSERT(m_workerClientWrapper);
-    m_workerClientWrapper->clearSyncMethodDone();
-}
-
 // Caller of this function should hold a reference to the bridge, because this function may call WebSocket::didClose() in the end,
 // which causes the bridge to get disconnected from the WebSocket and deleted if there is no other reference.
-void WorkerThreadableWebSocketChannel::Bridge::waitForMethodCompletion()
+bool WorkerThreadableWebSocketChannel::Bridge::waitForMethodCompletion()
 {
-    if (!m_workerGlobalScope)
-        return;
-    WorkerRunLoop& runLoop = m_workerGlobalScope->thread()->runLoop();
-    MessageQueueWaitResult result = MessageQueueMessageReceived;
-    ThreadableWebSocketChannelClientWrapper* clientWrapper = m_workerClientWrapper.get();
-    while (m_workerGlobalScope && clientWrapper && !clientWrapper->syncMethodDone() && result != MessageQueueTerminated) {
-        result = runLoop.runInMode(m_workerGlobalScope.get(), m_taskMode); // May cause this bridge to get disconnected, which makes m_workerGlobalScope become null.
-        clientWrapper = m_workerClientWrapper.get();
-    }
+    ASSERT(m_syncEvent);
+    if (!m_workerClientWrapper)
+        return true;
+
+    blink::WebWaitableEvent* shutdownEvent = m_workerGlobalScope->thread()->shutdownEvent();
+    Vector<blink::WebWaitableEvent*> events;
+    events.append(shutdownEvent);
+    events.append(m_syncEvent.get());
+
+    blink::WebWaitableEvent* signalled = blink::Platform::current()->waitMultipleEvents(events);
+    return signalled != shutdownEvent;
 }
 
 } // namespace WebCore
diff --git Source/modules/websockets/WorkerThreadableWebSocketChannel.h Source/modules/websockets/WorkerThreadableWebSocketChannel.h
index bce1650..7acb515 100644
--- Source/modules/websockets/WorkerThreadableWebSocketChannel.h
+++ Source/modules/websockets/WorkerThreadableWebSocketChannel.h
@@ -42,14 +42,20 @@
 #include "wtf/RefPtr.h"
 #include "wtf/Threading.h"
 #include "wtf/Vector.h"
+#include "wtf/WeakPtr.h"
 #include "wtf/text/WTFString.h"
 
+namespace blink {
+class WebWaitableEvent;
+}
+
 namespace WebCore {
 
 class BlobDataHandle;
 class KURL;
 class ExecutionContext;
 class ThreadableWebSocketChannelClientWrapper;
+class ThreadableWebSocketChannelSyncHelper;
 class WorkerGlobalScope;
 class WorkerLoaderProxy;
 class WorkerRunLoop;
@@ -78,22 +84,21 @@ public:
     virtual void resume() OVERRIDE;
 
     // Generated by the bridge. The Peer and its bridge should have identical
-    // lifetimes.
+    // lifetimes. All methods of this class must be called on the main thread.
     class Peer FINAL : public WebSocketChannelClient {
         WTF_MAKE_NONCOPYABLE(Peer); WTF_MAKE_FAST_ALLOCATED;
     public:
+        virtual ~Peer();
+
         // sourceURLAtConnection and lineNumberAtConnection parameters may
         // be shown when the connection fails.
-        static Peer* create(PassRefPtr<ThreadableWebSocketChannelClientWrapper> clientWrapper, WorkerLoaderProxy& loaderProxy, ExecutionContext* context, const String& taskMode, const String& sourceURLAtConnection, unsigned lineNumberAtConnection)
-        {
-            return new Peer(clientWrapper, loaderProxy, context, taskMode, sourceURLAtConnection, lineNumberAtConnection);
-        }
-        virtual ~Peer();
+        static void initialize(ExecutionContext*, PassRefPtr<WeakReference<Peer> >, WorkerLoaderProxy*, PassRefPtr<ThreadableWebSocketChannelClientWrapper>, const String& taskMode, const String& sourceURL, unsigned lineNumber, ThreadableWebSocketChannelSyncHelper*);
+        void destroy();
 
         void connect(const KURL&, const String& protocol);
         void send(const String& message);
-        void send(const ArrayBuffer&);
-        void send(PassRefPtr<BlobDataHandle>);
+        void sendArrayBuffer(PassOwnPtr<Vector<char> >);
+        void sendBlob(PassRefPtr<BlobDataHandle>);
         void bufferedAmount();
         void close(int code, const String& reason);
         void fail(const String& reason, MessageLevel, const String& sourceURL, unsigned lineNumber);
@@ -111,12 +116,14 @@ public:
         virtual void didReceiveMessageError() OVERRIDE;
 
     private:
-        Peer(PassRefPtr<ThreadableWebSocketChannelClientWrapper>, WorkerLoaderProxy&, ExecutionContext*, const String& taskMode, const String& sourceURL, unsigned lineNumber);
+        Peer(PassRefPtr<WeakReference<Peer> >, PassRefPtr<ThreadableWebSocketChannelClientWrapper>, WorkerLoaderProxy&, ExecutionContext*, const String& taskMode, const String& sourceURL, unsigned lineNumber, ThreadableWebSocketChannelSyncHelper&);
 
+        WeakPtrFactory<Peer> m_weakFactory;
         RefPtr<ThreadableWebSocketChannelClientWrapper> m_workerClientWrapper;
         WorkerLoaderProxy& m_loaderProxy;
         RefPtr<WebSocketChannel> m_mainWebSocketChannel;
         String m_taskMode;
+        ThreadableWebSocketChannelSyncHelper& m_syncHelper;
     };
 
     using RefCounted<WorkerThreadableWebSocketChannel>::ref;
@@ -158,40 +165,23 @@ private:
 
         static void setWebSocketChannel(ExecutionContext*, Bridge* thisPtr, Peer*, PassRefPtr<ThreadableWebSocketChannelClientWrapper>);
 
-        // Executed on the main thread to create a Peer for this bridge.
-        // sourceURL and lineNumber provides the source filename and
-        // the line number information at the connection initiation
-        // respectively. They may be shown when the connection fails.
-        static void mainThreadInitialize(ExecutionContext*, WorkerLoaderProxy*, PassRefPtr<ThreadableWebSocketChannelClientWrapper>, const String& taskMode, const String& sourceURL, unsigned lineNumber);
-
         // Executed on the worker context's thread.
         void clearClientWrapper();
 
-        void setMethodNotCompleted();
-        void waitForMethodCompletion();
+        // Returns false if shutdown event is received before method completion.
+        bool waitForMethodCompletion();
 
         RefPtr<ThreadableWebSocketChannelClientWrapper> m_workerClientWrapper;
         RefPtr<WorkerGlobalScope> m_workerGlobalScope;
         WorkerLoaderProxy& m_loaderProxy;
         String m_taskMode;
-        Peer* m_peer;
+        OwnPtr<blink::WebWaitableEvent> m_syncEvent;
+        OwnPtr<ThreadableWebSocketChannelSyncHelper> m_syncHelper;
+        WeakPtr<Peer> m_peer;
     };
 
     WorkerThreadableWebSocketChannel(WorkerGlobalScope*, WebSocketChannelClient*, const String& taskMode, const String& sourceURL, unsigned lineNumber);
 
-    static void mainThreadConnect(ExecutionContext*, Peer*, const KURL&, const String& protocol);
-    static void mainThreadSend(ExecutionContext*, Peer*, const String& message);
-    static void mainThreadSendArrayBuffer(ExecutionContext*, Peer*, PassOwnPtr<Vector<char> >);
-    static void mainThreadSendBlob(ExecutionContext*, Peer*, PassRefPtr<BlobDataHandle>);
-    static void mainThreadBufferedAmount(ExecutionContext*, Peer*);
-    static void mainThreadClose(ExecutionContext*, Peer*, int code, const String& reason);
-    static void mainThreadFail(ExecutionContext*, Peer*, const String& reason, MessageLevel, const String& sourceURL, unsigned lineNumber);
-    static void mainThreadDestroy(ExecutionContext*, PassOwnPtr<Peer>);
-    static void mainThreadSuspend(ExecutionContext*, Peer*);
-    static void mainThreadResume(ExecutionContext*, Peer*);
-
-    class WorkerGlobalScopeDidInitializeTask;
-
     RefPtr<WorkerGlobalScope> m_workerGlobalScope;
     RefPtr<ThreadableWebSocketChannelClientWrapper> m_workerClientWrapper;
     RefPtr<Bridge> m_bridge;
