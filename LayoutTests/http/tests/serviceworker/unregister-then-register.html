<!DOCTYPE html>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script src="resources/test-helpers.js"></script>
<script>
var worker_url = 'resources/empty-worker.js';

async_test(function(t) {
    var scope = 'scope/re-register-resolves-to-new-value';
    var iframe;
    var previous_registration;

    service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(registration) {
          previous_registration = registration;
          return wait_for_update(t, registration);
        })
      .then(function(worker) {
          return wait_for_state(t, worker, 'activated');
        })
      .then(function() {
          return navigator.serviceWorker.unregister(scope);
        })
      .then(function() {
          return navigator.serviceWorker.register(worker_url, { scope: scope });
        })
      .then(function(registration) {
          assert_not_equals(previous_registration, registration,
                            'register should resolve to a new value');
          service_worker_unregister_and_done(t, scope);
        })
      .catch(unreached_rejection(t));
  }, 'Unregister then register resolves to a new value');

async_test(function(t) {
    var scope = 'scope/re-register-while-old-registration-in-use';
    var previous_registration;

    service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(registration) {
          previous_registration = registration;
          return wait_for_update(t, registration);
        })
      .then(function(worker) {
          return wait_for_state(t, worker, 'activated');
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          return navigator.serviceWorker.unregister(scope);
        })
      .then(function() {
          return navigator.serviceWorker.register(worker_url, { scope: scope });
        })
      .then(function(registration) {
          assert_equals(previous_registration, registration,
                        'register should resolve to the same value');
          service_worker_unregister_and_done(t, scope);
        })
      .catch(unreached_rejection(t));
  }, 'Unregister then register resolves to the original value if the ' +
         'registration is in use.');

async_test(function(t) {
    var scope = 'scope/re-register-does-not-affect-existing-controllee';
    var iframe;

    service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(registration) {
          return wait_for_update(t, registration);
        })
      .then(function(registered_worker) {
          return wait_for_state(t, registered_worker, 'activated');
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          iframe = frame;
          worker = iframe.contentWindow.navigator.serviceWorker.controller;
          return navigator.serviceWorker.unregister(scope);
        })
      .then(function() {
          return navigator.serviceWorker.register(worker_url, { scope: scope });
        })
      .then(function(registration) {
          assert_equals(registration.installing, null,
                        'installing version is null');
          assert_equals(registration.waiting, null, 'waiting version is null');
          assert_equals(
              iframe.contentWindow.navigator.serviceWorker.controller, worker,
              'the worker from the first registration is the controller');
          service_worker_unregister_and_done(t, scope);
        })
      .catch(unreached_rejection(t));
  }, 'Unregister then register does not affect existing controllee');

async_test(function(t) {
    var scope = 'scope/resurrection';
    var iframe;
    var worker;

    service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(registration) {
          return wait_for_update(t, registration);
        })
      .then(function(registered_worker) {
          return wait_for_state(t, registered_worker, 'activated');
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          iframe = frame;
          worker = iframe.contentWindow.navigator.serviceWorker.controller;
          return navigator.serviceWorker.unregister(scope);
        })
      .then(function() {
          return navigator.serviceWorker.register(worker_url, { scope: scope });
        })
      .then(function(registered_worker) {
          return unload_iframe(iframe);
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          // FIXME: When crbug.com/400602 is fixed, assert that controller
          // equals the original worker.
          assert_not_equals(
              frame.contentWindow.navigator.serviceWorker.controller, null,
              'document should have a controller');
          service_worker_unregister_and_done(t, scope);
        })
      .catch(unreached_rejection(t));
  }, 'Unregister then register resurrects the registration');

async_test(function(t) {
    var scope = 'scope/new-worker';
    var new_worker_url = worker_url + '?new';
    var iframe;

    service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(registration) {
          return wait_for_update(t, registration);
        })
      .then(function(worker) {
          return wait_for_state(t, worker, 'activated');
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          iframe = frame;
          return navigator.serviceWorker.unregister(scope);
        })
      .then(function() {
          // FIXME: Register should not resolve until controllees are unloaded.
          return navigator.serviceWorker.register(new_worker_url,
                                                  { scope: scope });
        })
      .then(function(registration) {
          return wait_for_update(t, registration);
        })
      .then(function(worker) {
          return wait_for_state(t, worker, 'activated');
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          assert_equals(frame.contentWindow.navigator.serviceWorker.controller.scriptURL,
                        normalizeURL(new_worker_url),
                        'document controller is the new worker');
          service_worker_unregister_and_done(t, scope);
        })
      .catch(unreached_rejection(t));
}, 'Unregister then register a new script URL');

async_test(function(t) {
    var scope = 'scope/non-existent-worker';
    var iframe;

    service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(registration) {
          return wait_for_update(t, registration);
        })
      .then(function(worker) {
          return wait_for_state(t, worker, 'activated');
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          iframe = frame;
          return navigator.serviceWorker.unregister(scope);
        })
      .then(function() {
          // FIXME: Register should not resolve until controllees are unloaded.
          return navigator.serviceWorker.register('this-will-404',
                                                  { scope: scope });
        })
      .then(
        function() {
          assert_unreached('register should reject the promise');
        },
        function() {
          return unload_iframe(iframe);
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          assert_equals(frame.contentWindow.navigator.serviceWorker.controller,
                        null,
                        'document should not load with a controller');
          service_worker_unregister_and_done(t, scope);
        })
      .catch(unreached_rejection(t));
}, 'Registering a new script URL that 404s does not resurrect an ' +
       'unregistered registration');

async_test(function(t) {
    var scope = 'scope/reject-install-worker';
    var iframe;

    service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(registration) {
          return wait_for_update(t, registration);
        })
      .then(function(worker) {
          return wait_for_state(t, worker, 'activated');
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          iframe = frame;
          return navigator.serviceWorker.unregister();
        })
      .then(function() {
          // FIXME: Register should not resolve until controllees are unloaded.
          return navigator.serviceWorker.register(
              'resources/reject-install-worker.js', { scope: scope });
        })
      .then(function(registration) {
          return wait_for_update(t, registration);
        })
      .then(function(worker) {
          return wait_for_state(t, worker, 'redundant');
        })
      .then(function(worker) {
          return unload_iframe(iframe);
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          assert_equals(frame.contentWindow.navigator.serviceWorker.controller,
                        null,
                        'document should not load with a controller');
          service_worker_unregister_and_done(t, scope);
        })
      .catch(unreached_rejection(t));
  }, 'Registering a new script URL that fails to install does not resurrect ' +
       'an unregistered registration');
</script>
