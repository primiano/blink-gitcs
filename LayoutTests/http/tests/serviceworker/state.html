<!DOCTYPE html>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<body>
<script>
(function () {
    var t = async_test('Service Worker state property and "statechange" event');
    var currentState = 'test-is-starting';

    // FIXME: Unregister old Service Workers when unregister does not DCHECK.
    //navigator.serviceWorker.unregister('/state/*').then(register, register);
    register();

    function register() {
        navigator.serviceWorker.register(
            'resources/state-worker.js', {scope: '/state/*'}
        ).then(t.step_func(onRegister), t.step_func(onRegisterFail));
    }

    function onRegisterFail(reason) {
        assert_unreached('registration should not fail.');
        t.done();
    }

    function onRegister(sw) {
        sw.addEventListener('statechange', t.step_func(onStateChange));
        assert_in_array(sw.state, ['parsed', 'installing'],
                        'the service worker should be in a state up to ' +
                        '"installing".');
        checkStateTransition(sw.state);

        // FIXME: registration.html causes this test to get stuck in
        // state "parsed." When unregister works, remove this
        // premature exit to stop test timeouts.
        if (sw.state == 'parsed') {
            assert_unreached('wedged in state "parsed".');
            t.done();
        }
    }

    function checkStateTransition(newState) {
        switch (currentState) {
        case 'test-is-starting':
            break; // anything goes
        case 'parsed':
            assert_equals(newState, 'installing');
            break;
        case 'installing':
            assert_in_array(newState, ['installed', 'deactivated']);
            break;
        case 'installed':
            // FIXME: Remove "active" from this set when activation flow is
            // implemented.
            assert_in_array(newState, ['active', 'activating', 'deactivated']);
            break;
        case 'activating':
            assert_in_array(newState, ['active', 'deactivated']);
            break;
        case 'active':
            assert_equals(newState, 'deactivated');
            break;
        case 'deactivated':
            assert_unreached('a ServiceWorker should not transition out of ' +
                             'the "deactivated" state');
            break;
        default:
            assert_unreached('should not transition into unknown state "' +
                             newState + '"');
            break;
        }
        currentState = newState;
    }

    function onStateChange(event) {
        assert_true(event.target instanceof ServiceWorker,
                    'the target of the statechange event should be a ' +
                    'ServiceWorker.');
        assert_equals(event.type, 'statechange',
                      'the type of the event should be "statechange".');

        checkStateTransition(event.target.state);

        if (event.target.state == 'active') {
            t.done();
        }
    }
}());
</script>
