<!DOCTYPE html>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script src="resources/test-helpers.js"></script>
<script>
var worker_url = 'resources/empty-worker.js';

async_test(function(t) {
  var scope = 'scope/subsequent-register';
  var worker;
  var previous_registration;

  service_worker_unregister_and_register(t, worker_url, scope)
    .then(function(registration) {
        previous_registration = registration;
        return wait_for_update(t, registration);
      })
    .then(function(installing_worker) {
        worker = installing_worker;
        return wait_for_state(t, worker, 'activated');
      })
    .then(function() {
        return navigator.serviceWorker.register(worker_url, { scope: scope });
      })
    .then(function(registration) {
        assert_equals(previous_registration, registration,
                      'register should resolve to the same registration');
        // FIXME: When crbug.com/400602 is fixed, assert that active equals the
        // original worker.
        assert_not_equals(registration.active, worker,
                          'register should resolve to the same worker');
        assert_equals(registration.active.state, 'activated',
                     'the worker should be in state "activated"');
        service_worker_unregister_and_done(t, scope);
      })
    .catch(unreached_rejection(t));
}, 'Subsequent registrations resolve to the same registration object');

async_test(function(t) {
  var scope = 'scope/subsequent-register-from-different-iframe';
  var frame;
  var registration;

  service_worker_unregister_and_register(t, worker_url, scope)
    .then(function(r) {
        registration = r;
        return wait_for_state(t, registration.installing, 'activated');
      })
    .then(function() { return with_iframe('out-of-scope'); })
    .then(function(f) {
        frame = f;
        return frame.contentWindow.navigator.serviceWorker.register(
            worker_url, { scope: scope });
      })
    .then(function(new_registration) {
        assert_not_equals(
          registration, new_registration,
          'register should resolve to the different registration');
        assert_equals(
          registration.scope, new_registration.scope,
          'registrations should have the same scope');

        assert_equals(
          registration.installing, null,
          'installing worker should be null');
        assert_equals(
          new_registration.installing, null,
          'installing worker should be null');
        assert_equals(
          registration.waiting, null,
          'waiting worker should be null')
        assert_equals(
          new_registration.waiting, null,
          'waiting worker should be null')

        assert_not_equals(
          registration.active, new_registration.active,
          'registration should have the different active worker');
        assert_equals(
          registration.active.scriptURL,
          new_registration.active.scriptURL,
          'active workers should have the same script URL');
        assert_equals(
          registration.active.state,
          new_registration.active.state,
          'active workers should be in the same state');

        unload_iframe(frame);
        service_worker_unregister_and_done(t, scope);
      })
    .catch(unreached_rejection(t));
}, 'Subsequent registrations from a different iframe resolve to the ' +
       'different registration object but they refer to the same ' +
       'registration and workers');

async_test(function(t) {
  var scope = 'scope/concurrent-register';

  navigator.serviceWorker.unregister(scope)
    .then(function() {
        var promises = [];
        for (var i = 0; i < 100; ++i) {
          promises.push(navigator.serviceWorker.register(worker_url,
                                                         { scope: scope }));
        }
        return Promise.all(promises);
      })
    .then(function(registrations) {
        registrations.forEach(function(registration) {
            assert_equals(registration, registrations[0],
                          'register should resolve to the same registration');
        });
        service_worker_unregister_and_done(t, scope);
      })
    .catch(unreached_rejection(t));
}, 'Concurrent registrations resolve to the same registration object');

async_test(function(t) {
    var scope = 'scope/multiple-frames';
    var previous_registration;

    service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(registration) {
          previous_registration = registration;
          return with_iframe('nothing-here.html');
        })
      .then(function(frame) {
          return frame.contentWindow.navigator.serviceWorker.register(
              worker_url, { scope: scope });
        })
      .then(function(registration) {
          assert_not_equals(previous_registration, registration);
          service_worker_unregister_and_done(t, scope);
        })
      .catch(unreached_rejection(t));
  }, 'Registrations in separate frames resolve to different ' +
         'registration objects');
</script>
