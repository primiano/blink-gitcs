{% from "macros.tmpl" import wrap_with_condition, license -%}
{{ license() }}

#include "config.h"
#include "core/css/resolver/StyleBuilder.h"

#include "StyleBuilderFunctions.h"
#include "core/css/CSSPrimitiveValueMappings.h"
#include "core/css/resolver/StyleResolver.h"

// FIXME: currently we're just generating a switch statement, but we should
//   test other variations for performance once we have more properties here.

{%- macro set_value(property) -%}
    state.style()->{{property.setter}}
{%- endmacro %}

namespace WebCore {

{%- macro apply_value_length(property) -%}
    if (!value->isPrimitiveValue())
        return;

    CSSPrimitiveValue* primitiveValue = toCSSPrimitiveValue(value);
    Length length;
    switch(primitiveValue->getValueID()) {

{%- if property.use_none %}
    case CSSValueNone:
        length = Length(Undefined);
        break;
{%- endif %}

{%- if property.use_intrinsic %}
    case CSSValueIntrinsic:
        length = Length(Intrinsic);
        break;
    case CSSValueMinIntrinsic:
        length = Length(MinIntrinsic);
        break;
    case CSSValueWebkitMinContent:
        length = Length(MinContent);
        break;
    case CSSValueWebkitMaxContent:
        length = Length(MaxContent);
        break;
    case CSSValueWebkitFillAvailable:
        length = Length(FillAvailable);
        break;
    case CSSValueWebkitFitContent:
        length = Length(FitContent);
        break;
{%- endif %}

{%- if property.use_auto %}
    case CSSValueAuto:
        break; // default ctor is auto
{%- endif %}

    case CSSValueInvalid:
        length = primitiveValue->convertToLength<FixedIntegerConversion | CalculatedConversion | PercentConversion | ViewportPercentageConversion>(state.style(), state.rootElementStyle(), state.style()->effectiveZoom());
        length.setQuirk(primitiveValue->isQuirkValue());
        break;
    default:
        ASSERT_NOT_REACHED();
    }
    {{ set_value(property) }}(length);
{%- endmacro %}

{%- for property_id, property in properties.items() if not property.use_handlers_for %}
{%- call wrap_with_condition(property.condition) %}
{%- set apply_type = property.apply_type %}

{%- if not property.custom_initial %}
void StyleBuilderFunctions::applyInitial{{property_id}}(StyleResolver* styleResolver, StyleResolverState& state)
{
    {{ set_value(property) }}(RenderStyle::{{property.initial}}());
}
{% endif %}

{%- if not property.custom_inherit %}
void StyleBuilderFunctions::applyInherit{{property_id}}(StyleResolver* styleResolver, StyleResolverState& state)
{
    {{ set_value(property) }}(state.parentStyle()->{{property.getter}}());
}
{% endif %}

{%- if not property.custom_value %}
void StyleBuilderFunctions::applyValue{{property_id}}(StyleResolver* styleResolver, StyleResolverState& state, CSSValue* value)
{
{%- if apply_type == "length" %}
    {{ apply_value_length(property) }}
{%- else %}
    {{ set_value(property) }}(static_cast<{{property.type_name}}>(*toCSSPrimitiveValue(value)));
{%- endif %}
}
{% endif %}

{%- endcall %}
{%- endfor %}

bool StyleBuilder::applyProperty(CSSPropertyID property, StyleResolver* styleResolver, StyleResolverState& state, CSSValue* value, bool isInitial, bool isInherit) {
    switch(property) {
{%- for property_id, property in properties.items() %}
{%- set used_property = properties[property.use_handlers_for] or property %}
{%- set used_property_id = used_property.property_id %}
{%- call wrap_with_condition(used_property.condition) %}
    case {{ property_id }}:
        if (isInitial)
            StyleBuilderFunctions::applyInitial{{ used_property_id }}(styleResolver, state);
        else if (isInherit)
            StyleBuilderFunctions::applyInherit{{ used_property_id }}(styleResolver, state);
        else
            StyleBuilderFunctions::applyValue{{ used_property_id }}(styleResolver, state, value);
        return true;
{%- endcall %}
{% endfor %}
    default:
        return false;
    }
}

} // namespace WebCore

