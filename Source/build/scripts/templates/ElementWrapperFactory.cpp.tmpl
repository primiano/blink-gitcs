{% from "macros.tmpl" import license %}
{{ license() }}

#include "config.h"
#include "V8{{namespace}}ElementWrapperFactory.h"

#include "{{namespace}}Names.h"
{% for tag in tags|sort if tag.has_js_interface %}
#include "bindings/core/v8/V8{{tag.interface}}.h"
{% endfor %}
{% for tag in tags|sort if tag.has_js_interface %}
#include "core/{{namespace|lower}}/{{tag.js_interface}}.h"
{% endfor %}
#include "core/{{namespace|lower}}/{{fallback_js_interface}}.h"
#include "core/dom/Document.h"
#include "core/frame/Settings.h"
#include "platform/RuntimeEnabledFeatures.h"
#include "wtf/StdLibExtras.h"

namespace blink {

using namespace {{namespace}}Names;

const WrapperTypeInfo* findWrapperTypeFor{{namespace}}TagName(const AtomicString& name)
{
    typedef HashMap<StringImpl*, const WrapperTypeInfo*> NameTypeMap;
    DEFINE_STATIC_LOCAL(NameTypeMap, map, ());
    if (map.isEmpty()) {
        // FIXME: This seems wrong. We should list every interface here, not
        // just the ones that have specialized JavaScript interfaces.
        {% for tag in tags|sort if tag.has_js_interface %}
        {% filter enable_conditional(tag.Conditional) %}
        map.set({{tag|symbol}}Tag.localName().impl(), &V8{{tag.js_interface}}::wrapperTypeInfo);
        {% endfilter %}
        {% endfor %}
    }

    if (const WrapperTypeInfo* result = map.get(name.impl()))
        return result;

    return &V8{{fallback_js_interface}}::wrapperTypeInfo;
}

} // namespace blink
