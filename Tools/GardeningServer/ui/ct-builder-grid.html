<!--
Copyright 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="ct-builder.html">

<!-- Table of failure types, listing the failing builders for each type. -->
<polymer-element name="ct-builder-grid" attributes="failures builderLatestRevisions">
  <template>
    <style>
      table {
        border-collapse: collapse;
        font-size: 11px;
        table-layout: fixed;
        width: 350px;
      }

      tbody td:first-child {
        width: 20%;
      }

      tbody td {
        padding: 2px;
        vertical-align: top;
        width: 40%;
      }

      tr :first-child span {
        padding: 0 2px;
      }

      .TIMEOUT span {
        background-color: #fffc6c;
      }

      .TEXT span {
        background-color: #e98080;
      }

      .CRASH span {
        background-color: #ffc343;
      }

      .AUDIO span {
        background-color: #bfdfff;
      }

      .IMAGE span {
        background-color: #69f;
      }

      .IMAGE\+TEXT span {
        background-color: #96f;
      }

      .MISSING span {
        padding-left: 0px;
      }

      .BUILDING, .BUILDING ~ td {
        opacity: 0.5;
      }
    </style>
    <table>
      <thead>
        <tr>
          <td>type</td>
          <td>release</td>
          <td>debug</td>
        </tr>
      </thead>
      <tbody>
        <template repeat="{{ type in resultTypes|resultTypeKeys }}">
          <tr>
            <td class="{{ type }}">
              <span>{{ type }}</span>
            </td>
            <td>
              <template repeat="{{ builder in resultTypes[type]|keys }}">
                <template if="{{ !resultTypes[type][builder].debug }}">
                  <ct-builder builderName="{{ builder }}"></ct-builder>
                </template>
              </template>
            </td>
            <td>
              <template repeat="{{ builder in resultTypes[type]|keys }}">
                <template if="{{ resultTypes[type][builder].debug }}">
                  <ct-builder builderName="{{ builder }}"></ct-builder>
                </template>
              </template>
            </td>
          </tr>
        </template>
      </tbody>
    </table>
  </template>
  <script>
    Polymer({
      failures: [],
      builderLatestRevisions: {},
      resultTypes: {},

      keys: function(obj) {
        return Object.keys(obj).sort();
      },

      resultTypeKeys: function(obj) {
        // Get the keys, but the BUILDING type should be last.
        var keys = this.keys(obj);
        var index = keys.indexOf('BUILDING');
        if (index != -1) {
          var buildingResult = keys.splice(index, 1);
          keys.push(buildingResult[0]);
        }
        return keys;
      },

      failuresChanged: function() {
        // Create a set of builders for each result type (e.g., text, crash).
        this.resultTypes = {};
        var passingRevisions = [];
        this.failures.forEach(function(failure) {
          passingRevisions.push(failure.newestPassingRevision);
          var results = failure.resultNodesByBuilder;
          Object.keys(results, (function(builder) {
            var result = results[builder];
            if (!result.is_unexpected)
              return;

            if (!Object.has(this.resultTypes, result.actual))
              this.resultTypes[result.actual] = {};
            this.resultTypes[result.actual][builder] =
                config.builders[builder];
          }).bind(this));
        }, this);

        var buildingType = this._getBuilding(passingRevisions);
        if (!Object.isEmpty(buildingType))
            this.resultTypes['BUILDING'] = buildingType;
      },

      _buildersInFlightForRevision: function(revision) {
        return Object.keys(this.builderLatestRevisions).filter(function(builder) {
          // FIXME: This should look at all chromium/v8/etc revisions as well.
          // Is this concept of "building" builders even useful as is?
          return parseInt(this.builderLatestRevisions[builder].blink, 10) < revision;
        }.bind(this));
      },

      _getBuilding: function(revisions) {
        var building = {};
        var builders = [];
        revisions.unique().forEach(function(revision) {
          builders.push.apply(builders, this._buildersInFlightForRevision(revision + 1));
        }.bind(this));

        builders.unique().forEach(function(builder) {
          if (!config.builders[builder])
            return;
          building[builder] = {'debug': config.builders[builder].debug};
        });

        return building;
      },
    });
  </script>
</polymer-element>
