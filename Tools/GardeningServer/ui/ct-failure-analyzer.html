<!--
Copyright 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="../model/ct-failure.html">

<polymer-element name="ct-failure-analyzer" attributes="failures builderLatestRevisions">
  <script>
    // FIXME: Don't use a polymer component for this. Instead use a Failures model
    // object that knows how to do the XHR and process the data appropriately.
    Polymer({
      builderLatestRevisions: {},
      failures: {},

      update: function() {
        net.json('http://auto-sheriff.appspot.com/data').then(function(data) {
          // FIXME: Don't special-case the blink master.
          this.builderLatestRevisions = data.latest_revisions['chromium.webkit'];
          this.failures = [];
          data.range_groups.forEach(function(group) {
            this._processFailuresForGroup(group, data.alerts);
          }.bind(this));
          // FIXME: Sort this.failures by severity of regression, then by oldestFailingRevision.
        }.bind(this));
      },

      _failureComparator: function(a, b) {
        if (a.step > b.step)
          return 1;
        if (a.step < b.step)
          return -1
        if (a.testName > b.testName)
          return 1;
        if (a.testName < b.testName)
          return -1
        return 0;
      },

      _processFailuresForGroup: function(group, failures) {
        var failuresByReason = {};

        group.failure_keys.forEach(function(failure_key) {
          var failure = failures.find(function(item) { return item.key == failure_key; });
          if (failure.ignored_by.length)
            return;

          // FIXME: Make sheriff-o-matic work for all waterfalls.
          if (!failure.master_url.endsWith('chromium.webkit'))
            return;

          var reason, failureType;
          if (failure.reason) {
            // FIXME: Store the actual failure type in a different field instead of smashing it into the reason.
            var parts = failure.reason.split(':');
            reason = parts[0];
            failureType = parts[1] || 'FAIL';
          } else {
            reason = null;
            failureType = 'UNKNOWN';
          }

          var failureKey = JSON.stringify({
            step: failure.step_name,
            reason: reason,
          });

          // FIXME: Use a model class instead of a dumb object.
          if (!failuresByReason[failureKey])
            failuresByReason[failureKey] = {};
          // FIXME: If we have multiple builders with the same name across masters in
          // a failure group, then this will incorrectly overwrite one of the values.
          failuresByReason[failureKey][failure.builder_name] = {
            // FIXME: Rename to failureType.
            actual: failureType,
            lastFailingBuild: failure.last_failing_build,
            masterUrl: failure.master_url,
          };
        }.bind(this));

        var groupedFailures = [];

        var oldestFailingRevision, newestPassingRevision;
        // FIXME: This is a workaround for the backend's bogus data when the blink
        // regression ranges have no overlap.
        if (group.merged_last_passing && group.merged_first_failing.blink > group.merged_last_passing.blink) {
          oldestFailingRevision = Number(group.merged_first_failing.blink);
          newestPassingRevision = Number(group.merged_last_passing.blink);
        }

        Object.keys(failuresByReason, function(failureKey, resultByBuilder) {
          var failure = JSON.parse(failureKey);
          groupedFailures.push(new CTFailure(failure.step, failure.reason, resultByBuilder, oldestFailingRevision, newestPassingRevision));
        });

        // FIXME: Make this a model class intead of a dumb object.
        groupedFailures.sort(this._failureComparator);

        if (groupedFailures.length)
          this.failures.push(groupedFailures);
      },
    });
  </script>
</polymer-element>
